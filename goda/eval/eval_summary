処理速度測定概要（詳細についてはCryptDB_eval_dataを参照）

OSSのCryptDBは論文で紹介されているCryptDBといくつかの点で差異がある。
このプロジェクトでは実装されていない機能と、処理の最適化が行われていないという点に関して検証を行う。

■■■■■処理速度について（MySQLと比較を行う）■■■■■

■TPC-C基準でのトランザクション測定
TPC-C基準でのスコアで比較すると、MySQLに比べて約22倍の時間がかかる。
（MySQL：約550(トランザクション/m)　CryptDB：約26(トランザクション/m))
しかし、TPC-Cのスコアはinsertベースのトランザクションで測定されており、CryptDBはinsertの性能が悪くなる実装をされている。
よって、TPC-Cのスコアでは平等な比較を行うことができない。

→クエリタイプごとの処理時間を測定する。


■クエリタイプごとでの処理速度測定
TPC-Cで実行されるクエリを以下の8タイプに分類、処理時間を測定、比較する。

SELECT_EQUAL	イコール比較を条件に持つ選択クエリ
SELECT_RANGE	大小比較を条件に持つ選択クエリ
SELECT_JOIN	等結合後、SELECT_EQUALを行うクエリ
SELECT_SUM	集約演算を行うクエリ
INSERT		INSERTクエリ
DELETE		DELETEクエリ
UPDATE_SET	UPDATEクエリのうち、値を新たに設定するクエリ（例：price = 30）
UPDATE_INC	UPDATEクエリのうち、値に加算を行うクエリ（例：price = price + 20）

結果は以下の通りとなった。

	倍率（CryptDB/MySQL)
SELECT_EQUAL	42.362 
SELECT_RANGE	64.561 
SELECT_JOIN	28.600 
SELECT_SUM	64.713 
INSERT		202.544 
DELETE		21.940 
UPDATE_SET	93.220 
UPDATE_INC	115.432 
AVERAGE		74.240 

・INSERTは非常に遅い
・SElECT_EQUALやSELECT_RANGEも40倍以上の時間がかかっているが、これらに関してはクエリ実行時間は変わらないはずである。
　（暗号化前のデータの値が等しい場合、暗号化されたDB内でもデータが等しく、通常時とDB内処理は同じとなるため）

→CryptDB内の詳細な処理時間を計測する。


■詳細処理時間測定
CryptDB内の各処理にかかっている時間をそれぞれ分類し、測定する。

実行前処理	クエリ実行のための初期化等
クエリ変換	クエリ内容の解析、暗号化、カラム名等の変更を行う
クエリ実行	プロキシからサーバに大してクエリを実行、プロキシに結果が帰ってくるまでの時間
プロキシ表示	サーバから受け取ったクエリ結果（暗号化状態）をプロキシ画面に表示
クライアント表示	暗号化されている結果を複合、クライアントの画面に出力する

以下、代表としてSELECT_RANGEの場合の処理時間を載せる。

		処理時間(ms)
処理準備	0.111 
クエリ書き換え	3.453 
クエリ実行準備	0.002 
クエリ実行	4.460 
表示準備	0.411 
プロキシ表示	0.498 
クライアント表示	4.066 
総時間		12.587 

クエリ実行に約4.5ms時間がかかっている。
MySQLではクエリ全体が0.2msで実行できているのと比べると非常に遅い。

→理論として、クエリ実行はそれほど遅くなるはずがないため、CryptDBを動作させるために時間がかかっていると予想、分析する。


■非暗号化時の実行時間測定
CryptDBを経由し、しかしクエリ・値の暗号化を行わない場合の実行時間を測定することで、CryptDBのシステムでかかっている時間を測定する。

		SELECT_RANGE(ms)	
		暗号化	非暗号化
処理準備	0.111 	0.191 
クエリ書き換え	3.453 	2.250 
クエリ実行準備	0.002 	0.064 
クエリ実行	4.460 	3.245 
表示準備	0.411 	0.000 
プロキシ表示	0.498 	0.000 
クライアント表示	4.066 	3.857 
総時間		12.587 	9.607 

クエリ実行中に暗号化・複合を行う必要がなくなるため、クエリ実行時間が短くなるが、それでも3.2msかかっている。

→データ件数を変化させ、データ件数0件の場合の処理時間を予想する。


■データ件数を変化させた場合の処理時間測定
データ件数を1倍、2倍、5倍の場合で測定し、データ件数が0件（CryptDBのシステムの処理時間）の場合の時間を予想する。

		SELECT_RANGE(ms)		
		×1	×2	×5
処理準備	0.111	0.110	0.062
クエリ書き換え	3.453	3.516	1.968
クエリ実行準備	0.002	0.001	0.001
クエリ実行	4.460	6.266	19.166
表示準備	0.411	0.406	0.238
プロキシ表示	0.498	0.489	0.292
クライアント表示	4.066	4.053	3.189
総時間		13.000	14.434	24.677

結果から、CryptDBにて約11.6msがかかっているものと予想される。
これはクエリ実行時間の中でも占める割合が非常に大きい。
OSSのCryptDBの処理速度を改善する場合この時間を短縮することが課題になるものと思われる。


■高速化案1.インデックスの利用
CryptDBの処理時間を高速化する手法として、インデックスの利用が考えられる。
現状のCryptDBではprimary keyのカラムに関してOrderオニオンにのみインデックスが作成される。
これに対して手動でインデックスを作成した場合にはEqオニオン、Orderオニオンの両方にインデックスが作成される。
→primary keyに対してうまくインデックスが使えていないと予想される。

手動でprimary keyに対してインデックスを作成した場合の処理時間を測定。
約80%の時間で実行が可能であることが分かった。
また、元の6%の時間で実行ができる、非常に効果の大きいクエリが存在する事も有り、インデックスを適宜作成することで高速化が見込めることがわかった。


■高速化案2.オニオンの事前複合
CryptDBではオニオン暗号化として、複数回暗号化された状態でDBにデータが格納されている。
しかし、比較の際に定数の暗号化、値の取得の際に複合が複数回必要となる。
事前にオニオンを最下層まで復号しておくことでこの時間の短縮を図る。

結果として、約90%の時間で実行が可能であることがわかった。
あまり重要でないデータの場合最下層まであらかじめ複合しておくことで処理の高速化が可能である。


■高速化案3.プロキシ画面の非表示
CryptDBではプロキシ画面表示が行われるようになっており、クエリの暗号化した結果や、クエリ結果（暗号化）を表示している。
しかし、実際にCryptDBを利用する場合を考えると、プロキシ画面の表示は必要ない。
プロキシ画面を表示しない場合の処理時間を測定する。

結果として、約80%の時間で実行が可能であることが分かった。
（プロキシ表示にもともとかかっていた時間に関しては詳細処理時間の測定を参照）


■高速化案の組み合わせ
高速化案1~3をすべて組み合わせた場合、元の84%の時間で実行が可能
SELECT_EQUAL、SELECT_SUMのクエリタイプでは元の61%の時間で実行できる等あり、クエリによって効果はことなる。

オニオンを最下層まで復号するとセキュリティが弱くなってしまうため、オニオンを除く高速化案1,3の組み合わせについても実行時間を測定した。
元の88%の時間で実行が可能となる。




■■■■■OSSのCryptDBにて未実装の機能■■■■■
本内容はgithub上のTPCC-CryptDBにも記載されている。
（https://github.com/GODA-S/tpcc-cryptdb)

■CryptDBにて利用できないカラム型が存在する。
利用可 
TINYINT,SMALLINT,MEDIUMINT,INTEGER,BIGINT,CHAR(),VARCHAR(),TINYBLOB,BLOB,MEDIUMBLOB,LONGBLOB

利用不可 
FLOAT,DOUBLE,DECIMAL,DATE,DATETIME,TIMESTAMP,TIME,YEAR,ENUM(),SET()

→未実装なだけだと思われる

■外部キー制約が利用不可能
→CryptDBでは他カラムとデータ比較が行えないため不可能

■prepared statementが利用不可能
構文のみ先にコンパイルし、値を変数として後から指定、クエリを実行する高速化のための機能
→未実装なだけだと思われる

■数値型に対してマイナスの値が格納不可能
→論理的には可能、未実装なだけだと思われる

■検索条件内に四則演算を含むクエリを実行不可能
検索条件内に四則演算を含むクエリ(例 WHERE price < max(price) -20)を実行することができない 
→値を暗号化しているため不可能

なお、定数同士の演算であれば理論上は問題ないはずだが、未実装のため定数同士の演算も不可能。
（例：WHERE price < 20 + 10)

■一部関数（COALEASE)が実行不可能
→COALEASEに関しては未実装なだけであると思われる。
（COALEASEは実装するためのスペースがプログラム内に存在、未実装）

関数によっては理論上不可能なものもあるかもしれない。

■サブクエリが利用不可能
暗号化によりサブクエリの結果と比較を行えないため実行不可能


未実装の機能の改善に関してはgithub上の本プロジェクトのissueにも記載している。






以上
